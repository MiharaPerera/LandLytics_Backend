{"ast":null,"code":"import { Marker, setOptions, divIcon, Control, DomUtil, extend, LayerGroup, DomEvent, Util, circle } from 'leaflet';\n\n/*!\nCopyright (c) 2016 Dominik Moritz\n\nThis file is part of the leaflet locate control. It is licensed under the MIT license.\nYou can find the project at: https://github.com/domoritz/leaflet-locatecontrol\n*/\nconst addClasses = (el, names) => {\n  names.split(\" \").forEach(className => {\n    el.classList.add(className);\n  });\n};\nconst removeClasses = (el, names) => {\n  names.split(\" \").forEach(className => {\n    el.classList.remove(className);\n  });\n};\n\n/**\n * Compatible with Circle but a true marker instead of a path\n */\nconst LocationMarker = Marker.extend({\n  initialize(latlng, options) {\n    setOptions(this, options);\n    this._latlng = latlng;\n    this.createIcon();\n  },\n  /**\n   * Create a styled circle location marker\n   */\n  createIcon() {\n    const opt = this.options;\n    let style = \"\";\n    if (opt.color !== undefined) {\n      style += `stroke:${opt.color};`;\n    }\n    if (opt.weight !== undefined) {\n      style += `stroke-width:${opt.weight};`;\n    }\n    if (opt.fillColor !== undefined) {\n      style += `fill:${opt.fillColor};`;\n    }\n    if (opt.fillOpacity !== undefined) {\n      style += `fill-opacity:${opt.fillOpacity};`;\n    }\n    if (opt.opacity !== undefined) {\n      style += `opacity:${opt.opacity};`;\n    }\n    const icon = this._getIconSVG(opt, style);\n    this._locationIcon = divIcon({\n      className: icon.className,\n      html: icon.svg,\n      iconSize: [icon.w, icon.h]\n    });\n    this.setIcon(this._locationIcon);\n  },\n  /**\n   * Return the raw svg for the shape\n   *\n   * Split so can be easily overridden\n   */\n  _getIconSVG(options, style) {\n    const r = options.radius;\n    const w = options.weight;\n    const s = r + w;\n    const s2 = s * 2;\n    const svg = `<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"${s2}\" height=\"${s2}\" version=\"1.1\" viewBox=\"-${s} -${s} ${s2} ${s2}\">` + '<circle r=\"' + r + '\" style=\"' + style + '\" />' + \"</svg>\";\n    return {\n      className: \"leaflet-control-locate-location\",\n      svg,\n      w: s2,\n      h: s2\n    };\n  },\n  setStyle(style) {\n    setOptions(this, style);\n    this.createIcon();\n  }\n});\nconst CompassMarker = LocationMarker.extend({\n  initialize(latlng, heading, options) {\n    setOptions(this, options);\n    this._latlng = latlng;\n    this._heading = heading;\n    this.createIcon();\n  },\n  setHeading(heading) {\n    this._heading = heading;\n  },\n  /**\n   * Create a styled arrow compass marker\n   */\n  _getIconSVG(options, style) {\n    const r = options.radius;\n    const w = options.width + options.weight;\n    const h = (r + options.depth + options.weight) * 2;\n    const path = `M0,0 l${options.width / 2},${options.depth} l-${w},0 z`;\n    const svgstyle = `transform: rotate(${this._heading}deg)`;\n    const svg = `<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"${w}\" height=\"${h}\" version=\"1.1\" viewBox=\"-${w / 2} 0 ${w} ${h}\" style=\"${svgstyle}\">` + '<path d=\"' + path + '\" style=\"' + style + '\" />' + \"</svg>\";\n    return {\n      className: \"leaflet-control-locate-heading\",\n      svg,\n      w,\n      h\n    };\n  }\n});\nconst LocateControl = Control.extend({\n  options: {\n    /** Position of the control */\n    position: \"topleft\",\n    /** The layer that the user's location should be drawn on. By default creates a new layer. */\n    layer: undefined,\n    /**\n     * Automatically sets the map view (zoom and pan) to the user's location as it updates.\n     * While the map is following the user's location, the control is in the `following` state,\n     * which changes the style of the control and the circle marker.\n     *\n     * Possible values:\n     *  - false: never updates the map view when location changes.\n     *  - 'once': set the view when the location is first determined\n     *  - 'always': always updates the map view when location changes.\n     *              The map view follows the user's location.\n     *  - 'untilPan': like 'always', except stops updating the\n     *                view if the user has manually panned the map.\n     *                The map view follows the user's location until she pans.\n     *  - 'untilPanOrZoom': (default) like 'always', except stops updating the\n     *                view if the user has manually panned the map.\n     *                The map view follows the user's location until she pans.\n     */\n    setView: \"untilPanOrZoom\",\n    /** Keep the current map zoom level when setting the view and only pan. */\n    keepCurrentZoomLevel: false,\n    /** After activating the plugin by clicking on the icon, zoom to the selected zoom level, even when keepCurrentZoomLevel is true. Set to 'false' to disable this feature. */\n    initialZoomLevel: false,\n    /**\n     * This callback can be used to override the viewport tracking\n     * This function should return a LatLngBounds object.\n     *\n     * For example to extend the viewport to ensure that a particular LatLng is visible:\n     *\n     * getLocationBounds: function(locationEvent) {\n     *    return locationEvent.bounds.extend([-33.873085, 151.219273]);\n     * },\n     */\n    getLocationBounds(locationEvent) {\n      return locationEvent.bounds;\n    },\n    /** Smooth pan and zoom to the location of the marker. Only works in Leaflet 1.0+. */\n    flyTo: false,\n    /**\n     * The user location can be inside and outside the current view when the user clicks on the\n     * control that is already active. Both cases can be configures separately.\n     * Possible values are:\n     *  - 'setView': zoom and pan to the current location\n     *  - 'stop': stop locating and remove the location marker\n     */\n    clickBehavior: {\n      /** What should happen if the user clicks on the control while the location is within the current view. */\n      inView: \"stop\",\n      /** What should happen if the user clicks on the control while the location is outside the current view. */\n      outOfView: \"setView\",\n      /**\n       * What should happen if the user clicks on the control while the location is within the current view\n       * and we could be following but are not. Defaults to a special value which inherits from 'inView';\n       */\n      inViewNotFollowing: \"inView\"\n    },\n    /**\n     * If set, save the map bounds just before centering to the user's\n     * location. When control is disabled, set the view back to the\n     * bounds that were saved.\n     */\n    returnToPrevBounds: false,\n    /**\n     * Keep a cache of the location after the user deactivates the control. If set to false, the user has to wait\n     * until the locate API returns a new location before they see where they are again.\n     */\n    cacheLocation: true,\n    /** If set, a circle that shows the location accuracy is drawn. */\n    drawCircle: true,\n    /** If set, the marker at the users' location is drawn. */\n    drawMarker: true,\n    /** If set and supported then show the compass heading */\n    showCompass: true,\n    /** The class to be used to create the marker. For example L.CircleMarker or L.Marker */\n    markerClass: LocationMarker,\n    /** The class us be used to create the compass bearing arrow */\n    compassClass: CompassMarker,\n    /** Accuracy circle style properties. NOTE these styles should match the css animations styles */\n    circleStyle: {\n      className: \"leaflet-control-locate-circle\",\n      color: \"#136AEC\",\n      fillColor: \"#136AEC\",\n      fillOpacity: 0.15,\n      weight: 0\n    },\n    /** Inner marker style properties. Only works if your marker class supports `setStyle`. */\n    markerStyle: {\n      className: \"leaflet-control-locate-marker\",\n      color: \"#fff\",\n      fillColor: \"#2A93EE\",\n      fillOpacity: 1,\n      weight: 3,\n      opacity: 1,\n      radius: 9\n    },\n    /** Compass */\n    compassStyle: {\n      fillColor: \"#2A93EE\",\n      fillOpacity: 1,\n      weight: 0,\n      color: \"#fff\",\n      opacity: 1,\n      radius: 9,\n      // How far is the arrow from the center of the marker\n      width: 9,\n      // Width of the arrow\n      depth: 6 // Length of the arrow\n    },\n    /**\n     * Changes to accuracy circle and inner marker while following.\n     * It is only necessary to provide the properties that should change.\n     */\n    followCircleStyle: {},\n    followMarkerStyle: {\n      // color: '#FFA500',\n      // fillColor: '#FFB000'\n    },\n    followCompassStyle: {},\n    /** The CSS class for the icon. For example fa-location-arrow or fa-map-marker */\n    icon: \"leaflet-control-locate-location-arrow\",\n    iconLoading: \"leaflet-control-locate-spinner\",\n    /** The element to be created for icons. For example span or i */\n    iconElementTag: \"span\",\n    /** The element to be created for the text. For example small or span */\n    textElementTag: \"small\",\n    /** Padding around the accuracy circle. */\n    circlePadding: [0, 0],\n    /** Use metric units. */\n    metric: true,\n    /**\n     * This callback can be used in case you would like to override button creation behavior.\n     * This is useful for DOM manipulation frameworks such as angular etc.\n     * This function should return an object with HtmlElement for the button (link property) and the icon (icon property).\n     */\n    createButtonCallback(container, options) {\n      const link = DomUtil.create(\"a\", \"leaflet-bar-part leaflet-bar-part-single\", container);\n      link.title = options.strings.title;\n      link.href = \"#\";\n      link.setAttribute(\"role\", \"button\");\n      const icon = DomUtil.create(options.iconElementTag, options.icon, link);\n      if (options.strings.text !== undefined) {\n        const text = DomUtil.create(options.textElementTag, \"leaflet-locate-text\", link);\n        text.textContent = options.strings.text;\n        link.classList.add(\"leaflet-locate-text-active\");\n        link.parentNode.style.display = \"flex\";\n        if (options.icon.length > 0) {\n          icon.classList.add(\"leaflet-locate-icon\");\n        }\n      }\n      return {\n        link,\n        icon\n      };\n    },\n    /** This event is called in case of any location error that is not a time out error. */\n    onLocationError(err, control) {\n      alert(err.message);\n    },\n    /**\n     * This event is called when the user's location is outside the bounds set on the map.\n     * The event is called repeatedly when the location changes.\n     */\n    onLocationOutsideMapBounds(control) {\n      control.stop();\n      alert(control.options.strings.outsideMapBoundsMsg);\n    },\n    /** Display a pop-up when the user click on the inner marker. */\n    showPopup: true,\n    strings: {\n      title: \"Show me where I am\",\n      metersUnit: \"meters\",\n      feetUnit: \"feet\",\n      popup: \"You are within {distance} {unit} from this point\",\n      outsideMapBoundsMsg: \"You seem located outside the boundaries of the map\"\n    },\n    /** The default options passed to leaflets locate method. */\n    locateOptions: {\n      maxZoom: Infinity,\n      watch: true,\n      // if you overwrite this, visualization cannot be updated\n      setView: false // have to set this to false because we have to\n      // do setView manually\n    }\n  },\n  initialize(options) {\n    // set default options if nothing is set (merge one step deep)\n    for (const i in options) {\n      if (typeof this.options[i] === \"object\") {\n        extend(this.options[i], options[i]);\n      } else {\n        this.options[i] = options[i];\n      }\n    }\n\n    // extend the follow marker style and circle from the normal style\n    this.options.followMarkerStyle = extend({}, this.options.markerStyle, this.options.followMarkerStyle);\n    this.options.followCircleStyle = extend({}, this.options.circleStyle, this.options.followCircleStyle);\n    this.options.followCompassStyle = extend({}, this.options.compassStyle, this.options.followCompassStyle);\n  },\n  /**\n   * Add control to map. Returns the container for the control.\n   */\n  onAdd(map) {\n    const container = DomUtil.create(\"div\", \"leaflet-control-locate leaflet-bar leaflet-control\");\n    this._container = container;\n    this._map = map;\n    this._layer = this.options.layer || new LayerGroup();\n    this._layer.addTo(map);\n    this._event = undefined;\n    this._compassHeading = null;\n    this._prevBounds = null;\n    const linkAndIcon = this.options.createButtonCallback(container, this.options);\n    this._link = linkAndIcon.link;\n    this._icon = linkAndIcon.icon;\n    DomEvent.on(this._link, \"click\", function (ev) {\n      DomEvent.stopPropagation(ev);\n      DomEvent.preventDefault(ev);\n      this._onClick();\n    }, this).on(this._link, \"dblclick\", DomEvent.stopPropagation);\n    this._resetVariables();\n    this._map.on(\"unload\", this._unload, this);\n    return container;\n  },\n  /**\n   * This method is called when the user clicks on the control.\n   */\n  _onClick() {\n    this._justClicked = true;\n    const wasFollowing = this._isFollowing();\n    this._userPanned = false;\n    this._userZoomed = false;\n    if (this._active && !this._event) {\n      // click while requesting\n      this.stop();\n    } else if (this._active) {\n      const behaviors = this.options.clickBehavior;\n      let behavior = behaviors.outOfView;\n      if (this._map.getBounds().contains(this._event.latlng)) {\n        behavior = wasFollowing ? behaviors.inView : behaviors.inViewNotFollowing;\n      }\n\n      // Allow inheriting from another behavior\n      if (behaviors[behavior]) {\n        behavior = behaviors[behavior];\n      }\n      switch (behavior) {\n        case \"setView\":\n          this.setView();\n          break;\n        case \"stop\":\n          this.stop();\n          if (this.options.returnToPrevBounds) {\n            const f = this.options.flyTo ? this._map.flyToBounds : this._map.fitBounds;\n            f.bind(this._map)(this._prevBounds);\n          }\n          break;\n      }\n    } else {\n      if (this.options.returnToPrevBounds) {\n        this._prevBounds = this._map.getBounds();\n      }\n      this.start();\n    }\n    this._updateContainerStyle();\n  },\n  /**\n   * Starts the plugin:\n   * - activates the engine\n   * - draws the marker (if coordinates available)\n   */\n  start() {\n    this._activate();\n    if (this._event) {\n      this._drawMarker(this._map);\n\n      // if we already have a location but the user clicked on the control\n      if (this.options.setView) {\n        this.setView();\n      }\n    }\n    this._updateContainerStyle();\n  },\n  /**\n   * Stops the plugin:\n   * - deactivates the engine\n   * - reinitializes the button\n   * - removes the marker\n   */\n  stop() {\n    this._deactivate();\n    this._cleanClasses();\n    this._resetVariables();\n    this._removeMarker();\n  },\n  /**\n   * Keep the control active but stop following the location\n   */\n  stopFollowing() {\n    this._userPanned = true;\n    this._updateContainerStyle();\n    this._drawMarker();\n  },\n  /**\n   * This method launches the location engine.\n   * It is called before the marker is updated,\n   * event if it does not mean that the event will be ready.\n   *\n   * Override it if you want to add more functionalities.\n   * It should set the this._active to true and do nothing if\n   * this._active is true.\n   */\n  _activate() {\n    if (this._active || !this._map) {\n      return;\n    }\n    this._map.locate(this.options.locateOptions);\n    this._map.fire(\"locateactivate\", this);\n    this._active = true;\n\n    // bind event listeners\n    this._map.on(\"locationfound\", this._onLocationFound, this);\n    this._map.on(\"locationerror\", this._onLocationError, this);\n    this._map.on(\"dragstart\", this._onDrag, this);\n    this._map.on(\"zoomstart\", this._onZoom, this);\n    this._map.on(\"zoomend\", this._onZoomEnd, this);\n    if (this.options.showCompass) {\n      const oriAbs = \"ondeviceorientationabsolute\" in window;\n      if (oriAbs || \"ondeviceorientation\" in window) {\n        const _this = this;\n        const deviceorientation = function () {\n          DomEvent.on(window, oriAbs ? \"deviceorientationabsolute\" : \"deviceorientation\", _this._onDeviceOrientation, _this);\n        };\n        if (DeviceOrientationEvent && typeof DeviceOrientationEvent.requestPermission === \"function\") {\n          DeviceOrientationEvent.requestPermission().then(function (permissionState) {\n            if (permissionState === \"granted\") {\n              deviceorientation();\n            }\n          });\n        } else {\n          deviceorientation();\n        }\n      }\n    }\n  },\n  /**\n   * Called to stop the location engine.\n   *\n   * Override it to shutdown any functionalities you added on start.\n   */\n  _deactivate() {\n    if (!this._active || !this._map) {\n      return;\n    }\n    this._map.stopLocate();\n    this._map.fire(\"locatedeactivate\", this);\n    this._active = false;\n    if (!this.options.cacheLocation) {\n      this._event = undefined;\n    }\n\n    // unbind event listeners\n    this._map.off(\"locationfound\", this._onLocationFound, this);\n    this._map.off(\"locationerror\", this._onLocationError, this);\n    this._map.off(\"dragstart\", this._onDrag, this);\n    this._map.off(\"zoomstart\", this._onZoom, this);\n    this._map.off(\"zoomend\", this._onZoomEnd, this);\n    if (this.options.showCompass) {\n      this._compassHeading = null;\n      if (\"ondeviceorientationabsolute\" in window) {\n        DomEvent.off(window, \"deviceorientationabsolute\", this._onDeviceOrientation, this);\n      } else if (\"ondeviceorientation\" in window) {\n        DomEvent.off(window, \"deviceorientation\", this._onDeviceOrientation, this);\n      }\n    }\n  },\n  /**\n   * Zoom (unless we should keep the zoom level) and an to the current view.\n   */\n  setView() {\n    this._drawMarker();\n    if (this._isOutsideMapBounds()) {\n      this._event = undefined; // clear the current location so we can get back into the bounds\n      this.options.onLocationOutsideMapBounds(this);\n    } else {\n      if (this._justClicked && this.options.initialZoomLevel !== false) {\n        let f = this.options.flyTo ? this._map.flyTo : this._map.setView;\n        f.bind(this._map)([this._event.latitude, this._event.longitude], this.options.initialZoomLevel);\n      } else if (this.options.keepCurrentZoomLevel) {\n        let f = this.options.flyTo ? this._map.flyTo : this._map.panTo;\n        f.bind(this._map)([this._event.latitude, this._event.longitude]);\n      } else {\n        let f = this.options.flyTo ? this._map.flyToBounds : this._map.fitBounds;\n        // Ignore zoom events while setting the viewport as these would stop following\n        this._ignoreEvent = true;\n        f.bind(this._map)(this.options.getLocationBounds(this._event), {\n          padding: this.options.circlePadding,\n          maxZoom: this.options.initialZoomLevel || this.options.locateOptions.maxZoom\n        });\n        Util.requestAnimFrame(function () {\n          // Wait until after the next animFrame because the flyTo can be async\n          this._ignoreEvent = false;\n        }, this);\n      }\n    }\n  },\n  /**\n   *\n   */\n  _drawCompass() {\n    if (!this._event) {\n      return;\n    }\n    const latlng = this._event.latlng;\n    if (this.options.showCompass && latlng && this._compassHeading !== null) {\n      const cStyle = this._isFollowing() ? this.options.followCompassStyle : this.options.compassStyle;\n      if (!this._compass) {\n        this._compass = new this.options.compassClass(latlng, this._compassHeading, cStyle).addTo(this._layer);\n      } else {\n        this._compass.setLatLng(latlng);\n        this._compass.setHeading(this._compassHeading);\n        // If the compassClass can be updated with setStyle, update it.\n        if (this._compass.setStyle) {\n          this._compass.setStyle(cStyle);\n        }\n      }\n      //\n    }\n    if (this._compass && (!this.options.showCompass || this._compassHeading === null)) {\n      this._compass.removeFrom(this._layer);\n      this._compass = null;\n    }\n  },\n  /**\n   * Draw the marker and accuracy circle on the map.\n   *\n   * Uses the event retrieved from onLocationFound from the map.\n   */\n  _drawMarker() {\n    if (this._event.accuracy === undefined) {\n      this._event.accuracy = 0;\n    }\n    const radius = this._event.accuracy;\n    const latlng = this._event.latlng;\n\n    // circle with the radius of the location's accuracy\n    if (this.options.drawCircle) {\n      const style = this._isFollowing() ? this.options.followCircleStyle : this.options.circleStyle;\n      if (!this._circle) {\n        this._circle = circle(latlng, radius, style).addTo(this._layer);\n      } else {\n        this._circle.setLatLng(latlng).setRadius(radius).setStyle(style);\n      }\n    }\n    let distance;\n    let unit;\n    if (this.options.metric) {\n      distance = radius.toFixed(0);\n      unit = this.options.strings.metersUnit;\n    } else {\n      distance = (radius * 3.2808399).toFixed(0);\n      unit = this.options.strings.feetUnit;\n    }\n\n    // small inner marker\n    if (this.options.drawMarker) {\n      const mStyle = this._isFollowing() ? this.options.followMarkerStyle : this.options.markerStyle;\n      if (!this._marker) {\n        this._marker = new this.options.markerClass(latlng, mStyle).addTo(this._layer);\n      } else {\n        this._marker.setLatLng(latlng);\n        // If the markerClass can be updated with setStyle, update it.\n        if (this._marker.setStyle) {\n          this._marker.setStyle(mStyle);\n        }\n      }\n    }\n    this._drawCompass();\n    const t = this.options.strings.popup;\n    function getPopupText() {\n      if (typeof t === \"string\") {\n        return Util.template(t, {\n          distance,\n          unit\n        });\n      } else if (typeof t === \"function\") {\n        return t({\n          distance,\n          unit\n        });\n      } else {\n        return t;\n      }\n    }\n    if (this.options.showPopup && t && this._marker) {\n      this._marker.bindPopup(getPopupText())._popup.setLatLng(latlng);\n    }\n    if (this.options.showPopup && t && this._compass) {\n      this._compass.bindPopup(getPopupText())._popup.setLatLng(latlng);\n    }\n  },\n  /**\n   * Remove the marker from map.\n   */\n  _removeMarker() {\n    this._layer.clearLayers();\n    this._marker = undefined;\n    this._circle = undefined;\n  },\n  /**\n   * Unload the plugin and all event listeners.\n   * Kind of the opposite of onAdd.\n   */\n  _unload() {\n    this.stop();\n    // May become undefined during HMR\n    if (this._map) {\n      this._map.off(\"unload\", this._unload, this);\n    }\n  },\n  /**\n   * Sets the compass heading\n   */\n  _setCompassHeading(angle) {\n    if (!isNaN(parseFloat(angle)) && isFinite(angle)) {\n      angle = Math.round(angle);\n      this._compassHeading = angle;\n      Util.requestAnimFrame(this._drawCompass, this);\n    } else {\n      this._compassHeading = null;\n    }\n  },\n  /**\n   * If the compass fails calibration just fail safely and remove the compass\n   */\n  _onCompassNeedsCalibration() {\n    this._setCompassHeading();\n  },\n  /**\n   * Process and normalise compass events\n   */\n  _onDeviceOrientation(e) {\n    if (!this._active) {\n      return;\n    }\n    if (e.webkitCompassHeading) {\n      // iOS\n      this._setCompassHeading(e.webkitCompassHeading);\n    } else if (e.absolute && e.alpha) {\n      // Android\n      this._setCompassHeading(360 - e.alpha);\n    }\n  },\n  /**\n   * Calls deactivate and dispatches an error.\n   */\n  _onLocationError(err) {\n    // ignore time out error if the location is watched\n    if (err.code == 3 && this.options.locateOptions.watch) {\n      return;\n    }\n    this.stop();\n    this.options.onLocationError(err, this);\n  },\n  /**\n   * Stores the received event and updates the marker.\n   */\n  _onLocationFound(e) {\n    // no need to do anything if the location has not changed\n    if (this._event && this._event.latlng.lat === e.latlng.lat && this._event.latlng.lng === e.latlng.lng && this._event.accuracy === e.accuracy) {\n      return;\n    }\n    if (!this._active) {\n      // we may have a stray event\n      return;\n    }\n    this._event = e;\n    this._drawMarker();\n    this._updateContainerStyle();\n    switch (this.options.setView) {\n      case \"once\":\n        if (this._justClicked) {\n          this.setView();\n        }\n        break;\n      case \"untilPan\":\n        if (!this._userPanned) {\n          this.setView();\n        }\n        break;\n      case \"untilPanOrZoom\":\n        if (!this._userPanned && !this._userZoomed) {\n          this.setView();\n        }\n        break;\n      case \"always\":\n        this.setView();\n        break;\n    }\n    this._justClicked = false;\n  },\n  /**\n   * When the user drags. Need a separate event so we can bind and unbind event listeners.\n   */\n  _onDrag() {\n    // only react to drags once we have a location\n    if (this._event && !this._ignoreEvent) {\n      this._userPanned = true;\n      this._updateContainerStyle();\n      this._drawMarker();\n    }\n  },\n  /**\n   * When the user zooms. Need a separate event so we can bind and unbind event listeners.\n   */\n  _onZoom() {\n    // only react to drags once we have a location\n    if (this._event && !this._ignoreEvent) {\n      this._userZoomed = true;\n      this._updateContainerStyle();\n      this._drawMarker();\n    }\n  },\n  /**\n   * After a zoom ends update the compass and handle sideways zooms\n   */\n  _onZoomEnd() {\n    if (this._event) {\n      this._drawCompass();\n    }\n    if (this._event && !this._ignoreEvent) {\n      // If we have zoomed in and out and ended up sideways treat it as a pan\n      if (this._marker && !this._map.getBounds().pad(-0.3).contains(this._marker.getLatLng())) {\n        this._userPanned = true;\n        this._updateContainerStyle();\n        this._drawMarker();\n      }\n    }\n  },\n  /**\n   * Compute whether the map is following the user location with pan and zoom.\n   */\n  _isFollowing() {\n    if (!this._active) {\n      return false;\n    }\n    if (this.options.setView === \"always\") {\n      return true;\n    } else if (this.options.setView === \"untilPan\") {\n      return !this._userPanned;\n    } else if (this.options.setView === \"untilPanOrZoom\") {\n      return !this._userPanned && !this._userZoomed;\n    }\n  },\n  /**\n   * Check if location is in map bounds\n   */\n  _isOutsideMapBounds() {\n    if (this._event === undefined) {\n      return false;\n    }\n    return this._map.options.maxBounds && !this._map.options.maxBounds.contains(this._event.latlng);\n  },\n  /**\n   * Toggles button class between following and active.\n   */\n  _updateContainerStyle() {\n    if (!this._container) {\n      return;\n    }\n    if (this._active && !this._event) {\n      // active but don't have a location yet\n      this._setClasses(\"requesting\");\n    } else if (this._isFollowing()) {\n      this._setClasses(\"following\");\n    } else if (this._active) {\n      this._setClasses(\"active\");\n    } else {\n      this._cleanClasses();\n    }\n  },\n  /**\n   * Sets the CSS classes for the state.\n   */\n  _setClasses(state) {\n    if (state == \"requesting\") {\n      removeClasses(this._container, \"active following\");\n      addClasses(this._container, \"requesting\");\n      removeClasses(this._icon, this.options.icon);\n      addClasses(this._icon, this.options.iconLoading);\n    } else if (state == \"active\") {\n      removeClasses(this._container, \"requesting following\");\n      addClasses(this._container, \"active\");\n      removeClasses(this._icon, this.options.iconLoading);\n      addClasses(this._icon, this.options.icon);\n    } else if (state == \"following\") {\n      removeClasses(this._container, \"requesting\");\n      addClasses(this._container, \"active following\");\n      removeClasses(this._icon, this.options.iconLoading);\n      addClasses(this._icon, this.options.icon);\n    }\n  },\n  /**\n   * Removes all classes from button.\n   */\n  _cleanClasses() {\n    DomUtil.removeClass(this._container, \"requesting\");\n    DomUtil.removeClass(this._container, \"active\");\n    DomUtil.removeClass(this._container, \"following\");\n    removeClasses(this._icon, this.options.iconLoading);\n    addClasses(this._icon, this.options.icon);\n  },\n  /**\n   * Reinitializes state variables.\n   */\n  _resetVariables() {\n    // whether locate is active or not\n    this._active = false;\n\n    // true if the control was clicked for the first time\n    // we need this so we can pan and zoom once we have the location\n    this._justClicked = false;\n\n    // true if the user has panned the map after clicking the control\n    this._userPanned = false;\n\n    // true if the user has zoomed the map after clicking the control\n    this._userZoomed = false;\n  }\n});\nfunction locate(options) {\n  return new LocateControl(options);\n}\nexport { CompassMarker, LocateControl, LocationMarker, locate };","map":{"version":3,"names":["Marker","setOptions","divIcon","Control","DomUtil","extend","LayerGroup","DomEvent","Util","circle","addClasses","el","names","split","forEach","className","classList","add","removeClasses","remove","LocationMarker","initialize","latlng","options","_latlng","createIcon","opt","style","color","undefined","weight","fillColor","fillOpacity","opacity","icon","_getIconSVG","_locationIcon","html","svg","iconSize","w","h","setIcon","r","radius","s","s2","setStyle","CompassMarker","heading","_heading","setHeading","width","depth","path","svgstyle","LocateControl","position","layer","setView","keepCurrentZoomLevel","initialZoomLevel","getLocationBounds","locationEvent","bounds","flyTo","clickBehavior","inView","outOfView","inViewNotFollowing","returnToPrevBounds","cacheLocation","drawCircle","drawMarker","showCompass","markerClass","compassClass","circleStyle","markerStyle","compassStyle","followCircleStyle","followMarkerStyle","followCompassStyle","iconLoading","iconElementTag","textElementTag","circlePadding","metric","createButtonCallback","container","link","create","title","strings","href","setAttribute","text","textContent","parentNode","display","length","onLocationError","err","control","alert","message","onLocationOutsideMapBounds","stop","outsideMapBoundsMsg","showPopup","metersUnit","feetUnit","popup","locateOptions","maxZoom","Infinity","watch","i","onAdd","map","_container","_map","_layer","addTo","_event","_compassHeading","_prevBounds","linkAndIcon","_link","_icon","on","ev","stopPropagation","preventDefault","_onClick","_resetVariables","_unload","_justClicked","wasFollowing","_isFollowing","_userPanned","_userZoomed","_active","behaviors","behavior","getBounds","contains","f","flyToBounds","fitBounds","bind","start","_updateContainerStyle","_activate","_drawMarker","_deactivate","_cleanClasses","_removeMarker","stopFollowing","locate","fire","_onLocationFound","_onLocationError","_onDrag","_onZoom","_onZoomEnd","oriAbs","window","_this","deviceorientation","_onDeviceOrientation","DeviceOrientationEvent","requestPermission","then","permissionState","stopLocate","off","_isOutsideMapBounds","latitude","longitude","panTo","_ignoreEvent","padding","requestAnimFrame","_drawCompass","cStyle","_compass","setLatLng","removeFrom","accuracy","_circle","setRadius","distance","unit","toFixed","mStyle","_marker","t","getPopupText","template","bindPopup","_popup","clearLayers","_setCompassHeading","angle","isNaN","parseFloat","isFinite","Math","round","_onCompassNeedsCalibration","e","webkitCompassHeading","absolute","alpha","code","lat","lng","pad","getLatLng","maxBounds","_setClasses","state","removeClass"],"sources":["C:/Users/shahn/OneDrive/ドキュメント/GitHub/LandLytics_Backend/Database Integration/node_modules/leaflet.locatecontrol/dist/L.Control.Locate.esm.js"],"sourcesContent":["import { Marker, setOptions, divIcon, Control, DomUtil, extend, LayerGroup, DomEvent, Util, circle } from 'leaflet';\n\n/*!\nCopyright (c) 2016 Dominik Moritz\n\nThis file is part of the leaflet locate control. It is licensed under the MIT license.\nYou can find the project at: https://github.com/domoritz/leaflet-locatecontrol\n*/\nconst addClasses = (el, names) => {\n  names.split(\" \").forEach((className) => {\n    el.classList.add(className);\n  });\n};\n\nconst removeClasses = (el, names) => {\n  names.split(\" \").forEach((className) => {\n    el.classList.remove(className);\n  });\n};\n\n/**\n * Compatible with Circle but a true marker instead of a path\n */\nconst LocationMarker = Marker.extend({\n  initialize(latlng, options) {\n    setOptions(this, options);\n    this._latlng = latlng;\n    this.createIcon();\n  },\n\n  /**\n   * Create a styled circle location marker\n   */\n  createIcon() {\n    const opt = this.options;\n\n    let style = \"\";\n\n    if (opt.color !== undefined) {\n      style += `stroke:${opt.color};`;\n    }\n    if (opt.weight !== undefined) {\n      style += `stroke-width:${opt.weight};`;\n    }\n    if (opt.fillColor !== undefined) {\n      style += `fill:${opt.fillColor};`;\n    }\n    if (opt.fillOpacity !== undefined) {\n      style += `fill-opacity:${opt.fillOpacity};`;\n    }\n    if (opt.opacity !== undefined) {\n      style += `opacity:${opt.opacity};`;\n    }\n\n    const icon = this._getIconSVG(opt, style);\n\n    this._locationIcon = divIcon({\n      className: icon.className,\n      html: icon.svg,\n      iconSize: [icon.w, icon.h]\n    });\n\n    this.setIcon(this._locationIcon);\n  },\n\n  /**\n   * Return the raw svg for the shape\n   *\n   * Split so can be easily overridden\n   */\n  _getIconSVG(options, style) {\n    const r = options.radius;\n    const w = options.weight;\n    const s = r + w;\n    const s2 = s * 2;\n    const svg =\n      `<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"${s2}\" height=\"${s2}\" version=\"1.1\" viewBox=\"-${s} -${s} ${s2} ${s2}\">` +\n      '<circle r=\"' +\n      r +\n      '\" style=\"' +\n      style +\n      '\" />' +\n      \"</svg>\";\n    return {\n      className: \"leaflet-control-locate-location\",\n      svg,\n      w: s2,\n      h: s2\n    };\n  },\n\n  setStyle(style) {\n    setOptions(this, style);\n    this.createIcon();\n  }\n});\n\nconst CompassMarker = LocationMarker.extend({\n  initialize(latlng, heading, options) {\n    setOptions(this, options);\n    this._latlng = latlng;\n    this._heading = heading;\n    this.createIcon();\n  },\n\n  setHeading(heading) {\n    this._heading = heading;\n  },\n\n  /**\n   * Create a styled arrow compass marker\n   */\n  _getIconSVG(options, style) {\n    const r = options.radius;\n    const w = options.width + options.weight;\n    const h = (r + options.depth + options.weight) * 2;\n    const path = `M0,0 l${options.width / 2},${options.depth} l-${w},0 z`;\n    const svgstyle = `transform: rotate(${this._heading}deg)`;\n    const svg =\n      `<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"${w}\" height=\"${h}\" version=\"1.1\" viewBox=\"-${w / 2} 0 ${w} ${h}\" style=\"${svgstyle}\">` +\n      '<path d=\"' +\n      path +\n      '\" style=\"' +\n      style +\n      '\" />' +\n      \"</svg>\";\n    return {\n      className: \"leaflet-control-locate-heading\",\n      svg,\n      w,\n      h\n    };\n  }\n});\n\nconst LocateControl = Control.extend({\n  options: {\n    /** Position of the control */\n    position: \"topleft\",\n    /** The layer that the user's location should be drawn on. By default creates a new layer. */\n    layer: undefined,\n    /**\n     * Automatically sets the map view (zoom and pan) to the user's location as it updates.\n     * While the map is following the user's location, the control is in the `following` state,\n     * which changes the style of the control and the circle marker.\n     *\n     * Possible values:\n     *  - false: never updates the map view when location changes.\n     *  - 'once': set the view when the location is first determined\n     *  - 'always': always updates the map view when location changes.\n     *              The map view follows the user's location.\n     *  - 'untilPan': like 'always', except stops updating the\n     *                view if the user has manually panned the map.\n     *                The map view follows the user's location until she pans.\n     *  - 'untilPanOrZoom': (default) like 'always', except stops updating the\n     *                view if the user has manually panned the map.\n     *                The map view follows the user's location until she pans.\n     */\n    setView: \"untilPanOrZoom\",\n    /** Keep the current map zoom level when setting the view and only pan. */\n    keepCurrentZoomLevel: false,\n    /** After activating the plugin by clicking on the icon, zoom to the selected zoom level, even when keepCurrentZoomLevel is true. Set to 'false' to disable this feature. */\n    initialZoomLevel: false,\n    /**\n     * This callback can be used to override the viewport tracking\n     * This function should return a LatLngBounds object.\n     *\n     * For example to extend the viewport to ensure that a particular LatLng is visible:\n     *\n     * getLocationBounds: function(locationEvent) {\n     *    return locationEvent.bounds.extend([-33.873085, 151.219273]);\n     * },\n     */\n    getLocationBounds(locationEvent) {\n      return locationEvent.bounds;\n    },\n    /** Smooth pan and zoom to the location of the marker. Only works in Leaflet 1.0+. */\n    flyTo: false,\n    /**\n     * The user location can be inside and outside the current view when the user clicks on the\n     * control that is already active. Both cases can be configures separately.\n     * Possible values are:\n     *  - 'setView': zoom and pan to the current location\n     *  - 'stop': stop locating and remove the location marker\n     */\n    clickBehavior: {\n      /** What should happen if the user clicks on the control while the location is within the current view. */\n      inView: \"stop\",\n      /** What should happen if the user clicks on the control while the location is outside the current view. */\n      outOfView: \"setView\",\n      /**\n       * What should happen if the user clicks on the control while the location is within the current view\n       * and we could be following but are not. Defaults to a special value which inherits from 'inView';\n       */\n      inViewNotFollowing: \"inView\"\n    },\n    /**\n     * If set, save the map bounds just before centering to the user's\n     * location. When control is disabled, set the view back to the\n     * bounds that were saved.\n     */\n    returnToPrevBounds: false,\n    /**\n     * Keep a cache of the location after the user deactivates the control. If set to false, the user has to wait\n     * until the locate API returns a new location before they see where they are again.\n     */\n    cacheLocation: true,\n    /** If set, a circle that shows the location accuracy is drawn. */\n    drawCircle: true,\n    /** If set, the marker at the users' location is drawn. */\n    drawMarker: true,\n    /** If set and supported then show the compass heading */\n    showCompass: true,\n    /** The class to be used to create the marker. For example L.CircleMarker or L.Marker */\n    markerClass: LocationMarker,\n    /** The class us be used to create the compass bearing arrow */\n    compassClass: CompassMarker,\n    /** Accuracy circle style properties. NOTE these styles should match the css animations styles */\n    circleStyle: {\n      className: \"leaflet-control-locate-circle\",\n      color: \"#136AEC\",\n      fillColor: \"#136AEC\",\n      fillOpacity: 0.15,\n      weight: 0\n    },\n    /** Inner marker style properties. Only works if your marker class supports `setStyle`. */\n    markerStyle: {\n      className: \"leaflet-control-locate-marker\",\n      color: \"#fff\",\n      fillColor: \"#2A93EE\",\n      fillOpacity: 1,\n      weight: 3,\n      opacity: 1,\n      radius: 9\n    },\n    /** Compass */\n    compassStyle: {\n      fillColor: \"#2A93EE\",\n      fillOpacity: 1,\n      weight: 0,\n      color: \"#fff\",\n      opacity: 1,\n      radius: 9, // How far is the arrow from the center of the marker\n      width: 9, // Width of the arrow\n      depth: 6 // Length of the arrow\n    },\n    /**\n     * Changes to accuracy circle and inner marker while following.\n     * It is only necessary to provide the properties that should change.\n     */\n    followCircleStyle: {},\n    followMarkerStyle: {\n      // color: '#FFA500',\n      // fillColor: '#FFB000'\n    },\n    followCompassStyle: {},\n    /** The CSS class for the icon. For example fa-location-arrow or fa-map-marker */\n    icon: \"leaflet-control-locate-location-arrow\",\n    iconLoading: \"leaflet-control-locate-spinner\",\n    /** The element to be created for icons. For example span or i */\n    iconElementTag: \"span\",\n    /** The element to be created for the text. For example small or span */\n    textElementTag: \"small\",\n    /** Padding around the accuracy circle. */\n    circlePadding: [0, 0],\n    /** Use metric units. */\n    metric: true,\n    /**\n     * This callback can be used in case you would like to override button creation behavior.\n     * This is useful for DOM manipulation frameworks such as angular etc.\n     * This function should return an object with HtmlElement for the button (link property) and the icon (icon property).\n     */\n    createButtonCallback(container, options) {\n      const link = DomUtil.create(\"a\", \"leaflet-bar-part leaflet-bar-part-single\", container);\n      link.title = options.strings.title;\n      link.href = \"#\";\n      link.setAttribute(\"role\", \"button\");\n      const icon = DomUtil.create(options.iconElementTag, options.icon, link);\n\n      if (options.strings.text !== undefined) {\n        const text = DomUtil.create(options.textElementTag, \"leaflet-locate-text\", link);\n        text.textContent = options.strings.text;\n        link.classList.add(\"leaflet-locate-text-active\");\n        link.parentNode.style.display = \"flex\";\n        if (options.icon.length > 0) {\n          icon.classList.add(\"leaflet-locate-icon\");\n        }\n      }\n\n      return { link, icon };\n    },\n    /** This event is called in case of any location error that is not a time out error. */\n    onLocationError(err, control) {\n      alert(err.message);\n    },\n    /**\n     * This event is called when the user's location is outside the bounds set on the map.\n     * The event is called repeatedly when the location changes.\n     */\n    onLocationOutsideMapBounds(control) {\n      control.stop();\n      alert(control.options.strings.outsideMapBoundsMsg);\n    },\n    /** Display a pop-up when the user click on the inner marker. */\n    showPopup: true,\n    strings: {\n      title: \"Show me where I am\",\n      metersUnit: \"meters\",\n      feetUnit: \"feet\",\n      popup: \"You are within {distance} {unit} from this point\",\n      outsideMapBoundsMsg: \"You seem located outside the boundaries of the map\"\n    },\n    /** The default options passed to leaflets locate method. */\n    locateOptions: {\n      maxZoom: Infinity,\n      watch: true, // if you overwrite this, visualization cannot be updated\n      setView: false // have to set this to false because we have to\n      // do setView manually\n    }\n  },\n\n  initialize(options) {\n    // set default options if nothing is set (merge one step deep)\n    for (const i in options) {\n      if (typeof this.options[i] === \"object\") {\n        extend(this.options[i], options[i]);\n      } else {\n        this.options[i] = options[i];\n      }\n    }\n\n    // extend the follow marker style and circle from the normal style\n    this.options.followMarkerStyle = extend({}, this.options.markerStyle, this.options.followMarkerStyle);\n    this.options.followCircleStyle = extend({}, this.options.circleStyle, this.options.followCircleStyle);\n    this.options.followCompassStyle = extend({}, this.options.compassStyle, this.options.followCompassStyle);\n  },\n\n  /**\n   * Add control to map. Returns the container for the control.\n   */\n  onAdd(map) {\n    const container = DomUtil.create(\"div\", \"leaflet-control-locate leaflet-bar leaflet-control\");\n    this._container = container;\n    this._map = map;\n    this._layer = this.options.layer || new LayerGroup();\n    this._layer.addTo(map);\n    this._event = undefined;\n    this._compassHeading = null;\n    this._prevBounds = null;\n\n    const linkAndIcon = this.options.createButtonCallback(container, this.options);\n    this._link = linkAndIcon.link;\n    this._icon = linkAndIcon.icon;\n\n    DomEvent.on(\n      this._link,\n      \"click\",\n      function (ev) {\n        DomEvent.stopPropagation(ev);\n        DomEvent.preventDefault(ev);\n        this._onClick();\n      },\n      this\n    ).on(this._link, \"dblclick\", DomEvent.stopPropagation);\n\n    this._resetVariables();\n\n    this._map.on(\"unload\", this._unload, this);\n\n    return container;\n  },\n\n  /**\n   * This method is called when the user clicks on the control.\n   */\n  _onClick() {\n    this._justClicked = true;\n    const wasFollowing = this._isFollowing();\n    this._userPanned = false;\n    this._userZoomed = false;\n\n    if (this._active && !this._event) {\n      // click while requesting\n      this.stop();\n    } else if (this._active) {\n      const behaviors = this.options.clickBehavior;\n      let behavior = behaviors.outOfView;\n      if (this._map.getBounds().contains(this._event.latlng)) {\n        behavior = wasFollowing ? behaviors.inView : behaviors.inViewNotFollowing;\n      }\n\n      // Allow inheriting from another behavior\n      if (behaviors[behavior]) {\n        behavior = behaviors[behavior];\n      }\n\n      switch (behavior) {\n        case \"setView\":\n          this.setView();\n          break;\n        case \"stop\":\n          this.stop();\n          if (this.options.returnToPrevBounds) {\n            const f = this.options.flyTo ? this._map.flyToBounds : this._map.fitBounds;\n            f.bind(this._map)(this._prevBounds);\n          }\n          break;\n      }\n    } else {\n      if (this.options.returnToPrevBounds) {\n        this._prevBounds = this._map.getBounds();\n      }\n      this.start();\n    }\n\n    this._updateContainerStyle();\n  },\n\n  /**\n   * Starts the plugin:\n   * - activates the engine\n   * - draws the marker (if coordinates available)\n   */\n  start() {\n    this._activate();\n\n    if (this._event) {\n      this._drawMarker(this._map);\n\n      // if we already have a location but the user clicked on the control\n      if (this.options.setView) {\n        this.setView();\n      }\n    }\n    this._updateContainerStyle();\n  },\n\n  /**\n   * Stops the plugin:\n   * - deactivates the engine\n   * - reinitializes the button\n   * - removes the marker\n   */\n  stop() {\n    this._deactivate();\n\n    this._cleanClasses();\n    this._resetVariables();\n\n    this._removeMarker();\n  },\n\n  /**\n   * Keep the control active but stop following the location\n   */\n  stopFollowing() {\n    this._userPanned = true;\n    this._updateContainerStyle();\n    this._drawMarker();\n  },\n\n  /**\n   * This method launches the location engine.\n   * It is called before the marker is updated,\n   * event if it does not mean that the event will be ready.\n   *\n   * Override it if you want to add more functionalities.\n   * It should set the this._active to true and do nothing if\n   * this._active is true.\n   */\n  _activate() {\n    if (this._active || !this._map) {\n      return;\n    }\n\n    this._map.locate(this.options.locateOptions);\n    this._map.fire(\"locateactivate\", this);\n    this._active = true;\n\n    // bind event listeners\n    this._map.on(\"locationfound\", this._onLocationFound, this);\n    this._map.on(\"locationerror\", this._onLocationError, this);\n    this._map.on(\"dragstart\", this._onDrag, this);\n    this._map.on(\"zoomstart\", this._onZoom, this);\n    this._map.on(\"zoomend\", this._onZoomEnd, this);\n    if (this.options.showCompass) {\n      const oriAbs = \"ondeviceorientationabsolute\" in window;\n      if (oriAbs || \"ondeviceorientation\" in window) {\n        const _this = this;\n        const deviceorientation = function () {\n          DomEvent.on(window, oriAbs ? \"deviceorientationabsolute\" : \"deviceorientation\", _this._onDeviceOrientation, _this);\n        };\n        if (DeviceOrientationEvent && typeof DeviceOrientationEvent.requestPermission === \"function\") {\n          DeviceOrientationEvent.requestPermission().then(function (permissionState) {\n            if (permissionState === \"granted\") {\n              deviceorientation();\n            }\n          });\n        } else {\n          deviceorientation();\n        }\n      }\n    }\n  },\n\n  /**\n   * Called to stop the location engine.\n   *\n   * Override it to shutdown any functionalities you added on start.\n   */\n  _deactivate() {\n    if (!this._active || !this._map) {\n      return;\n    }\n\n    this._map.stopLocate();\n    this._map.fire(\"locatedeactivate\", this);\n    this._active = false;\n\n    if (!this.options.cacheLocation) {\n      this._event = undefined;\n    }\n\n    // unbind event listeners\n    this._map.off(\"locationfound\", this._onLocationFound, this);\n    this._map.off(\"locationerror\", this._onLocationError, this);\n    this._map.off(\"dragstart\", this._onDrag, this);\n    this._map.off(\"zoomstart\", this._onZoom, this);\n    this._map.off(\"zoomend\", this._onZoomEnd, this);\n    if (this.options.showCompass) {\n      this._compassHeading = null;\n      if (\"ondeviceorientationabsolute\" in window) {\n        DomEvent.off(window, \"deviceorientationabsolute\", this._onDeviceOrientation, this);\n      } else if (\"ondeviceorientation\" in window) {\n        DomEvent.off(window, \"deviceorientation\", this._onDeviceOrientation, this);\n      }\n    }\n  },\n\n  /**\n   * Zoom (unless we should keep the zoom level) and an to the current view.\n   */\n  setView() {\n    this._drawMarker();\n    if (this._isOutsideMapBounds()) {\n      this._event = undefined; // clear the current location so we can get back into the bounds\n      this.options.onLocationOutsideMapBounds(this);\n    } else {\n      if (this._justClicked && this.options.initialZoomLevel !== false) {\n        let f = this.options.flyTo ? this._map.flyTo : this._map.setView;\n        f.bind(this._map)([this._event.latitude, this._event.longitude], this.options.initialZoomLevel);\n      } else if (this.options.keepCurrentZoomLevel) {\n        let f = this.options.flyTo ? this._map.flyTo : this._map.panTo;\n        f.bind(this._map)([this._event.latitude, this._event.longitude]);\n      } else {\n        let f = this.options.flyTo ? this._map.flyToBounds : this._map.fitBounds;\n        // Ignore zoom events while setting the viewport as these would stop following\n        this._ignoreEvent = true;\n        f.bind(this._map)(this.options.getLocationBounds(this._event), {\n          padding: this.options.circlePadding,\n          maxZoom: this.options.initialZoomLevel || this.options.locateOptions.maxZoom\n        });\n        Util.requestAnimFrame(function () {\n          // Wait until after the next animFrame because the flyTo can be async\n          this._ignoreEvent = false;\n        }, this);\n      }\n    }\n  },\n\n  /**\n   *\n   */\n  _drawCompass() {\n    if (!this._event) {\n      return;\n    }\n\n    const latlng = this._event.latlng;\n\n    if (this.options.showCompass && latlng && this._compassHeading !== null) {\n      const cStyle = this._isFollowing() ? this.options.followCompassStyle : this.options.compassStyle;\n      if (!this._compass) {\n        this._compass = new this.options.compassClass(latlng, this._compassHeading, cStyle).addTo(this._layer);\n      } else {\n        this._compass.setLatLng(latlng);\n        this._compass.setHeading(this._compassHeading);\n        // If the compassClass can be updated with setStyle, update it.\n        if (this._compass.setStyle) {\n          this._compass.setStyle(cStyle);\n        }\n      }\n      //\n    }\n    if (this._compass && (!this.options.showCompass || this._compassHeading === null)) {\n      this._compass.removeFrom(this._layer);\n      this._compass = null;\n    }\n  },\n\n  /**\n   * Draw the marker and accuracy circle on the map.\n   *\n   * Uses the event retrieved from onLocationFound from the map.\n   */\n  _drawMarker() {\n    if (this._event.accuracy === undefined) {\n      this._event.accuracy = 0;\n    }\n\n    const radius = this._event.accuracy;\n    const latlng = this._event.latlng;\n\n    // circle with the radius of the location's accuracy\n    if (this.options.drawCircle) {\n      const style = this._isFollowing() ? this.options.followCircleStyle : this.options.circleStyle;\n\n      if (!this._circle) {\n        this._circle = circle(latlng, radius, style).addTo(this._layer);\n      } else {\n        this._circle.setLatLng(latlng).setRadius(radius).setStyle(style);\n      }\n    }\n\n    let distance;\n    let unit;\n    if (this.options.metric) {\n      distance = radius.toFixed(0);\n      unit = this.options.strings.metersUnit;\n    } else {\n      distance = (radius * 3.2808399).toFixed(0);\n      unit = this.options.strings.feetUnit;\n    }\n\n    // small inner marker\n    if (this.options.drawMarker) {\n      const mStyle = this._isFollowing() ? this.options.followMarkerStyle : this.options.markerStyle;\n      if (!this._marker) {\n        this._marker = new this.options.markerClass(latlng, mStyle).addTo(this._layer);\n      } else {\n        this._marker.setLatLng(latlng);\n        // If the markerClass can be updated with setStyle, update it.\n        if (this._marker.setStyle) {\n          this._marker.setStyle(mStyle);\n        }\n      }\n    }\n\n    this._drawCompass();\n\n    const t = this.options.strings.popup;\n    function getPopupText() {\n      if (typeof t === \"string\") {\n        return Util.template(t, { distance, unit });\n      } else if (typeof t === \"function\") {\n        return t({ distance, unit });\n      } else {\n        return t;\n      }\n    }\n    if (this.options.showPopup && t && this._marker) {\n      this._marker.bindPopup(getPopupText())._popup.setLatLng(latlng);\n    }\n    if (this.options.showPopup && t && this._compass) {\n      this._compass.bindPopup(getPopupText())._popup.setLatLng(latlng);\n    }\n  },\n\n  /**\n   * Remove the marker from map.\n   */\n  _removeMarker() {\n    this._layer.clearLayers();\n    this._marker = undefined;\n    this._circle = undefined;\n  },\n\n  /**\n   * Unload the plugin and all event listeners.\n   * Kind of the opposite of onAdd.\n   */\n  _unload() {\n    this.stop();\n    // May become undefined during HMR\n    if (this._map) {\n      this._map.off(\"unload\", this._unload, this);\n    }\n  },\n\n  /**\n   * Sets the compass heading\n   */\n  _setCompassHeading(angle) {\n    if (!isNaN(parseFloat(angle)) && isFinite(angle)) {\n      angle = Math.round(angle);\n\n      this._compassHeading = angle;\n      Util.requestAnimFrame(this._drawCompass, this);\n    } else {\n      this._compassHeading = null;\n    }\n  },\n\n  /**\n   * If the compass fails calibration just fail safely and remove the compass\n   */\n  _onCompassNeedsCalibration() {\n    this._setCompassHeading();\n  },\n\n  /**\n   * Process and normalise compass events\n   */\n  _onDeviceOrientation(e) {\n    if (!this._active) {\n      return;\n    }\n\n    if (e.webkitCompassHeading) {\n      // iOS\n      this._setCompassHeading(e.webkitCompassHeading);\n    } else if (e.absolute && e.alpha) {\n      // Android\n      this._setCompassHeading(360 - e.alpha);\n    }\n  },\n\n  /**\n   * Calls deactivate and dispatches an error.\n   */\n  _onLocationError(err) {\n    // ignore time out error if the location is watched\n    if (err.code == 3 && this.options.locateOptions.watch) {\n      return;\n    }\n\n    this.stop();\n    this.options.onLocationError(err, this);\n  },\n\n  /**\n   * Stores the received event and updates the marker.\n   */\n  _onLocationFound(e) {\n    // no need to do anything if the location has not changed\n    if (this._event && this._event.latlng.lat === e.latlng.lat && this._event.latlng.lng === e.latlng.lng && this._event.accuracy === e.accuracy) {\n      return;\n    }\n\n    if (!this._active) {\n      // we may have a stray event\n      return;\n    }\n\n    this._event = e;\n\n    this._drawMarker();\n    this._updateContainerStyle();\n\n    switch (this.options.setView) {\n      case \"once\":\n        if (this._justClicked) {\n          this.setView();\n        }\n        break;\n      case \"untilPan\":\n        if (!this._userPanned) {\n          this.setView();\n        }\n        break;\n      case \"untilPanOrZoom\":\n        if (!this._userPanned && !this._userZoomed) {\n          this.setView();\n        }\n        break;\n      case \"always\":\n        this.setView();\n        break;\n    }\n\n    this._justClicked = false;\n  },\n\n  /**\n   * When the user drags. Need a separate event so we can bind and unbind event listeners.\n   */\n  _onDrag() {\n    // only react to drags once we have a location\n    if (this._event && !this._ignoreEvent) {\n      this._userPanned = true;\n      this._updateContainerStyle();\n      this._drawMarker();\n    }\n  },\n\n  /**\n   * When the user zooms. Need a separate event so we can bind and unbind event listeners.\n   */\n  _onZoom() {\n    // only react to drags once we have a location\n    if (this._event && !this._ignoreEvent) {\n      this._userZoomed = true;\n      this._updateContainerStyle();\n      this._drawMarker();\n    }\n  },\n\n  /**\n   * After a zoom ends update the compass and handle sideways zooms\n   */\n  _onZoomEnd() {\n    if (this._event) {\n      this._drawCompass();\n    }\n\n    if (this._event && !this._ignoreEvent) {\n      // If we have zoomed in and out and ended up sideways treat it as a pan\n      if (this._marker && !this._map.getBounds().pad(-0.3).contains(this._marker.getLatLng())) {\n        this._userPanned = true;\n        this._updateContainerStyle();\n        this._drawMarker();\n      }\n    }\n  },\n\n  /**\n   * Compute whether the map is following the user location with pan and zoom.\n   */\n  _isFollowing() {\n    if (!this._active) {\n      return false;\n    }\n\n    if (this.options.setView === \"always\") {\n      return true;\n    } else if (this.options.setView === \"untilPan\") {\n      return !this._userPanned;\n    } else if (this.options.setView === \"untilPanOrZoom\") {\n      return !this._userPanned && !this._userZoomed;\n    }\n  },\n\n  /**\n   * Check if location is in map bounds\n   */\n  _isOutsideMapBounds() {\n    if (this._event === undefined) {\n      return false;\n    }\n    return this._map.options.maxBounds && !this._map.options.maxBounds.contains(this._event.latlng);\n  },\n\n  /**\n   * Toggles button class between following and active.\n   */\n  _updateContainerStyle() {\n    if (!this._container) {\n      return;\n    }\n\n    if (this._active && !this._event) {\n      // active but don't have a location yet\n      this._setClasses(\"requesting\");\n    } else if (this._isFollowing()) {\n      this._setClasses(\"following\");\n    } else if (this._active) {\n      this._setClasses(\"active\");\n    } else {\n      this._cleanClasses();\n    }\n  },\n\n  /**\n   * Sets the CSS classes for the state.\n   */\n  _setClasses(state) {\n    if (state == \"requesting\") {\n      removeClasses(this._container, \"active following\");\n      addClasses(this._container, \"requesting\");\n\n      removeClasses(this._icon, this.options.icon);\n      addClasses(this._icon, this.options.iconLoading);\n    } else if (state == \"active\") {\n      removeClasses(this._container, \"requesting following\");\n      addClasses(this._container, \"active\");\n\n      removeClasses(this._icon, this.options.iconLoading);\n      addClasses(this._icon, this.options.icon);\n    } else if (state == \"following\") {\n      removeClasses(this._container, \"requesting\");\n      addClasses(this._container, \"active following\");\n\n      removeClasses(this._icon, this.options.iconLoading);\n      addClasses(this._icon, this.options.icon);\n    }\n  },\n\n  /**\n   * Removes all classes from button.\n   */\n  _cleanClasses() {\n    DomUtil.removeClass(this._container, \"requesting\");\n    DomUtil.removeClass(this._container, \"active\");\n    DomUtil.removeClass(this._container, \"following\");\n\n    removeClasses(this._icon, this.options.iconLoading);\n    addClasses(this._icon, this.options.icon);\n  },\n\n  /**\n   * Reinitializes state variables.\n   */\n  _resetVariables() {\n    // whether locate is active or not\n    this._active = false;\n\n    // true if the control was clicked for the first time\n    // we need this so we can pan and zoom once we have the location\n    this._justClicked = false;\n\n    // true if the user has panned the map after clicking the control\n    this._userPanned = false;\n\n    // true if the user has zoomed the map after clicking the control\n    this._userZoomed = false;\n  }\n});\n\nfunction locate(options) {\n  return new LocateControl(options);\n}\n\nexport { CompassMarker, LocateControl, LocationMarker, locate };\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}